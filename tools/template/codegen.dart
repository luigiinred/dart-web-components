// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#library('codegen');

#import('dart:coreimpl');
#import('../../lib/html5parser/tokenkind.dart');
#import('../../lib/html5parser/htmltree.dart');
#import('../css/css.dart', prefix:'css');
#import('../lib/world.dart');
#import('compile.dart');
#import('utils.dart');

/**
 * Support routines to generate Dart code.
 */
class Codegen {
  static final String SPACES = "                                              ";
  static String spaces(int numSpaces) {
    return SPACES.substring(0, numSpaces);
  }

  static String imports(String parentsDotDot) => """


#import('dart:html');
#import('${parentsDotDot}component.dart');
#import('${parentsDotDot}watcher.dart');
#import('${parentsDotDot}webcomponents.dart');
#import('${parentsDotDot}tools/lib/data_template.dart');

""";

  static String libraryAndImports(String libraryName, int parentsPathCount) {
    StringBuffer buff = new StringBuffer();

    buff.add("#library('$libraryName');");

    String parentsDotDot = "";
    while (parentsPathCount-- > 0) {
      parentsDotDot = "$parentsDotDot../";
    }
    buff.add("${imports(parentsDotDot)}");

    return buff.toString();
  }

  /**
   *  Epilog of the render function; injects the nodes into the live document
   *  to make everything visible.
   */
  static String renderNodes = @"""


    var nodes = templateRoot.nodes;
    while (nodes.length > 0) {
      parent.nodes.add(nodes[0]);
    }""";

  /*
   * [filename] passed in would be filename part (sans '.extension').
   */
  static String generate(HTMLDocument doc, int parentsPathCount,
                         String libraryName, String filename, ElemCG ecg) {
    // TODO(terry): Validate that the filename matches identifier:
    //              a..z || A..Z || _ [a..z || A..Z || 0..9 || _]*
    if (libraryName.indexOf('.') >= 0) {
      world.fatal("Bad library - $libraryName");
    }

    StringBuffer buff = new StringBuffer();
    int injectId = 0;         // Inject function id

    buff.add("// Generated Dart class from HTML template $filename.\n");
    buff.add("// DO NOT EDIT.\n\n");

    buff.add(libraryAndImports(libraryName, parentsPathCount));

    if (ecg.includes.length > 0) {
      buff.add("/** Below import from script tag in HTML file. */\n");
      for (var includeName in ecg.includes) {
        buff.add("#import('$includeName');\n");
      }
      buff.add("\n");
    }

    String buildHTML = ecg.applicationCodeBody();
    String body = "\n    var frag = new DocumentFragment();$buildHTML";
    buff.add(_emitApplicationClass("MyApplication", body, "MyTemplate"));

    int idx = 1;
    while (true) {
      CGBlock cgb = ecg.templateCG(idx++);
      if (cgb != null) {
        int boundElementCount = cgb.boundElementCount;
        if (ecg.isWebComponent) {
          buff.add(_emitWebComponentClass(ecg.className,
                _emitWCClassBody(ecg),
                boundElementCount,
                "    DocumentFragment templateRoot = new DocumentFragment();\n${
                cgb.codeBody}$renderNodes",
                templateExprFuncs: cgb.templatesCodeBody(ecg.expressions),
                injectFuncs: injectionsCode(ecg)));

        } else {
          // Top-level template.
          // TODO(terry): Hard coded class name should use constructor attr?
          buff.add(_emitTemplateClass("MyTemplate",
              boundElementCount,
              "    DocumentFragment templateRoot = new DocumentFragment();\n${
              cgb.codeBody}$renderNodes",
              templateExprFuncs: cgb.templatesCodeBody(ecg.expressions),
              injectFuncs: injectionsCode(ecg)));
        }
      } else {
        break;
      }
    }

    return buff.toString();
  }

  static String _emitWCClassBody(ElemCG ecg) {
    Expect.isTrue(ecg.isWebComponent);

    StringBuffer buff = new StringBuffer();

    buff.add("  /** User written code associated with this component 'item.html'. */\n");
    buff.add(ecg.userCode);

    buff.add("\n");

    buff.add("  /** Autogenerated from the template. */\n");

    return buff.toString();
  }

  static String genInjectsCommentBlock = @"""

  // ==================================================================
  // Injection functions:
  // ==================================================================""";

  static String injectionsCode(ecg) {
    StringBuffer buff = new StringBuffer();

    // Emit all injection functions.
    buff.add(genInjectsCommentBlock);
    var index = 0;
    for (var expr in ecg.expressions) {
      buff.add("\n  inject_$index() => safeHTML(model.$expr);");
      index++;
    }

    return buff.toString();
  }

  static String _emitClass(String className,
                           String extendsName,
                           [String classBodyCode = null,
                            String params = null,
                            String initializer = null,
                            String body = null,
                            List<String> funcs = null,
                            String epilog = null]) {
    StringBuffer buff = new StringBuffer();
    buff.add(
        "\nclass $className extends $extendsName {\n");

    if (classBodyCode != null) {
      buff.add(classBodyCode);
    }

    bool constructParams = params != null && !params.isEmpty();
    buff.add("  $className(${constructParams ? params: ''}) ");

    buff.add(classBodyCode);

    bool constructInitializer = initializer != null && !initializer.isEmpty();
    buff.add("${constructInitializer ? ': $initializer' : ''}");

    bool constructBody = body != null && !body.isEmpty();
    buff.add("${constructBody ? ' {$body\n  }' : ';'}");

    bool anyFuncs = funcs != null && funcs.length > 0;
    if (anyFuncs) {
      for (String func in funcs) {
        if (func.trim().length > 0) {
          buff.add("\n\n");
          buff.add("  $func");
        }
      }
    }

    if (epilog != null && epilog.length > 0) {
      buff.add(epilog);
    }

    buff.add("\n}\n");

    return buff.toString();
  }

  static String _emitApplicationClass(String genClassName, String construcBody,
                                      String templateClassName) {
    List<String> myFuncs = [
      "Template createTemplate(var templateParent) => new ${
        templateClassName}(controller, templateParent);",
    ];
    return _emitClass(genClassName, 'Application',
        params: 'var controller',
        initializer: 'super(controller)',
        body: construcBody,
        funcs: myFuncs);
  }

  static String _emitTemplateClass(String genClassName,
                                   int boundElementCount,
                                   String renderBody,
                                   [String templateExprFuncs = "",
                                    String injectFuncs = ""]) {
    StringBuffer buff = new StringBuffer();
    int i = 0;
    while (i < boundElementCount) {
      buff.add("\n    boundElements.add(new BoundElementEntry(templateLine_${
          i++}));");
    }

    List<String> myFuncs = [
      "void render() {\n$renderBody\n  }",
    ];
    return _emitClass(genClassName, "Template",
                       params: 'var ctrl, Element parent',
                       initializer: 'super(ctrl, parent)',
                       body: buff.toString(),
                       funcs: myFuncs,
                       epilog: "${templateExprFuncs}$injectFuncs");
  }

  static String _emitWebComponentClass(String genClassName,
                                       String classBodyUserCode,
                                       int boundElementCount,
                                       String renderBody,
                                       [String templateExprFuncs = "",
                                        String injectFuncs = ""]) {
    StringBuffer buff = new StringBuffer();
    int i = 0;
    while (i < boundElementCount) {
      buff.add("\n    boundElements.add(new BoundElementEntry(templateLine_${
          i++}));");
    }

    List<String> myFuncs = [
      "void render() {\n$renderBody\n  }",
    ];
    return _emitClass(genClassName, "Component",
                      classBodyCode: classBodyUserCode,
                      params: 'var ctrl, Element parent',
                      initializer: 'super(ctrl, parent)',
                      body: buff.toString(),
                      funcs: myFuncs,
                      epilog: "${templateExprFuncs}$injectFuncs");
  }

  static String _emitCSSSelectors(css.Stylesheet stylesheet) {
    if (stylesheet == null) {
      return "";
    }

    SplayTreeMap<String, css.CssData> classes;

    for (final production in stylesheet.topLevels) {
      if (production is css.IncludeDirective) {
        for (final topLevel in production.styleSheet.topLevels) {
          if (topLevel is css.RuleSet) {
            classes = css.Generate.computeClassSelectors(topLevel, classes);
          }
        }
      } else if (production is css.RuleSet) {
        classes = css.Generate.computeClassSelectors(production, classes);
      }
    }

    if (classes == null) {
      classes = new SplayTreeMap<String, css.CssData>();
    }

    var buff = new StringBuffer();
    for (final String knownClass in classes.getKeys()) {
      var dartName = toCamelCase(knownClass);
      buff.add("  static String get ${dartName}() => \"${knownClass}\";\n");
    }

    return buff.toString();
  }
}
